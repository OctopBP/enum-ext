using System;
using System.Linq;
using System.Reflection;
using System.Threading;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace PublicAccessor;

internal partial class PublicAccessorGenerator {
  const string PublicAccessorAttributeName = "PublicAccessorAttribute";

  static readonly AssemblyName assemblyName = typeof(PublicAccessorGenerator).Assembly.GetName();
  static readonly string generatedCodeAttribute =
    $@"global::System.CodeDom.Compiler.GeneratedCodeAttribute(""{assemblyName.Name}"", ""{assemblyName.Version}"")";

  static readonly string PublicAccessorAttribute = $@"// <auto-generated/>
#nullable enable

// namespace Roslyn.Generated;

[{generatedCodeAttribute}]
[global::System.AttributeUsage(global::System.AttributeTargets.Field, AllowMultiple = false)]
internal sealed class PublicAccessorAttribute : global::System.Attribute {{ }}
";

  static bool HasAttribute(
    FieldDeclarationSyntax candidate, string attributeName, SemanticModel semanticModel,
    CancellationToken cancellationToken
  ) => candidate.AttributeLists
    .SelectMany(attributeList => attributeList.Attributes
      .Select(attribute => semanticModel.GetSymbolInfo(attribute, cancellationToken))
      .Select(info => info.Symbol)
    )
    .Any(symbol =>
      symbol is IMethodSymbol method
      && method.ContainingType.ToDisplayString().Equals(attributeName, StringComparison.Ordinal)
    );
}