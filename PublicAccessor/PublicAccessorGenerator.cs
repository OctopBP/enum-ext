using System.Diagnostics;
using System.Linq;
using System.Runtime.CompilerServices;
using System.Threading;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace PublicAccessor;

[Generator]
internal sealed partial class PublicAccessorGenerator : IIncrementalGenerator {
  class ClassData {
    public readonly string @namespace;
    public readonly string className;
    public readonly VariableData[] variables;
    
    public ClassData(string @namespace, string className, VariableData[] variables) {
      this.@namespace = @namespace;
      this.className = className;
      this.variables = variables;
    }
  }
  
  class VariableData {
    public readonly string type;
    public readonly string name;
    
    public VariableData(string type, string name) {
      this.type = type;
      this.name = name;
    }
  }
  
  public void Initialize(IncrementalGeneratorInitializationContext context) {
    context.RegisterPostInitializationOutput(PostInitializationOutput);

    var provider = context.SyntaxProvider.CreateSyntaxProvider(
      ClassWithFieldsWithAttributesPredicate,
      TransformToClassData
    );
    context.RegisterSourceOutput(provider, Execute);
  }
  
  static void PostInitializationOutput(IncrementalGeneratorPostInitializationContext context) =>
    context.AddSource($"{PublicAccessorAttributeName}.g.cs", PublicAccessorAttribute);

  static bool ClassWithFieldsWithAttributesPredicate(SyntaxNode syntaxNode, CancellationToken _) =>
    syntaxNode is ClassDeclarationSyntax @class
    && @class.ChildNodes().Any(node =>
      node is FieldDeclarationSyntax { AttributeLists.Count: > 0 } field
      && !field.Modifiers.Any(SyntaxKind.PublicKeyword)
      && !field.Modifiers.Any(SyntaxKind.StaticKeyword)
    );

  static ClassData TransformToClassData(GeneratorSyntaxContext context, CancellationToken cancellationToken) {
    Debug.Assert(context.Node is ClassDeclarationSyntax);

    var @class = Unsafe.As<ClassDeclarationSyntax>(context.Node);
    var variables = context.Node.ChildNodes()
      .Where(n =>
        n is FieldDeclarationSyntax f
        && HasAttribute(f, PublicAccessorAttributeName, context.SemanticModel, cancellationToken)
      )
      .Select(Unsafe.As<FieldDeclarationSyntax>)
      .Where(field => !field.Modifiers.Any(SyntaxKind.PublicKeyword) && !field.Modifiers.Any(SyntaxKind.StaticKeyword))
      .SelectMany(field => field.Declaration.Variables.Select(variable => (field, variable)))
      .Select(tpl => {
        var type = tpl.field.Declaration.Type.ToString();
        var name = tpl.variable.Identifier.Text;
        return new VariableData(type, name);
      })
      .ToArray();

    var classSymbol = context.SemanticModel.GetDeclaredSymbol(@class, cancellationToken);
    return classSymbol != null && variables.Any()
      ? new(
        @namespace: string.Join(".", classSymbol.ContainingNamespace.ConstituentNamespaces),
        className: classSymbol.Name,
        variables: variables
      )
      : default;
  }

  static void Execute(SourceProductionContext context, ClassData classData) {
    var hintName = $"{classData.className}.transformed.g.cs";
    var variableStrings = classData.variables.Select(variableString).ToArray();

    context.AddSource(
      hintName,
      @$"// <auto-generated>
// ReSharper disable all

namespace {classData.@namespace} {{
  public partial class {classData.className} {{
{string.Join("\n\n", variableStrings)}
  }}
}}"
    );

    string variableString(VariableData field) => @$"    /// <inheritdoc cref = ""{field.name}""/>
    public {field.type} _{field.name} => {field.name};";
  }
}