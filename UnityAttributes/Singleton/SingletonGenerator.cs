using System.Collections.Generic;
using System.Linq;
using System.Runtime.CompilerServices;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;
using UnityAttributes.Common;

namespace UnityAttributes.Singleton; 

[Generator]
public partial class SingletonGenerator : ISourceGenerator
{
  static readonly string generatedCodeAttribute = typeof(SingletonGenerator).generatedCodeAttribute();

  public void Initialize(GeneratorInitializationContext context)
  {
    context.RegisterForPostInitialization(i => i.AddSource($"{AttributeName}.g.cs", attributeText));
    context.RegisterForSyntaxNotifications(() => new SyntaxReceiver());
  }

  public void Execute(GeneratorExecutionContext context)
  {
    if (context.SyntaxContextReceiver is not SyntaxReceiver receiver)
      return;

    foreach (var classSymbol in receiver.classes)
    {
      var classSource = processClass(classSymbol);
      context.AddSource($"{classSymbol}.singleton.g.cs", SourceText.From(classSource, Encoding.UTF8));
    }
  }

  static string processClass(INamedTypeSymbol classSymbol)
  {
    var codeBuilder = new CodeBuilder();

    codeBuilder.append(Const.AutoGeneratedText);
    codeBuilder.appendEmptyLine();
    codeBuilder.appendEmptyLine();
    
    if (!classSymbol.ContainingNamespace.IsGlobalNamespace)
    {
      codeBuilder.appendLine(
        text: $"namespace {string.Join(".", classSymbol.ContainingNamespace.ConstituentNamespaces)} {{",
        identChange: CodeBuilder.IdentChange.IncreaseAfter
      );
    }

    var containingTypes = new List<INamedTypeSymbol>();
    var containingType = classSymbol.ContainingType;
    var indentCount = 0;
    while (containingType != null)
    {
      containingTypes.Add(containingType);
      containingType = containingType.ContainingType;
      indentCount++;
    }

    containingTypes.Reverse();
    foreach (var type in containingTypes)
    {
      codeBuilder.appendLine($"public partial class {type.Name}");
      codeBuilder.appendLine("{", CodeBuilder.IdentChange.IncreaseAfter);
    }
    
    codeBuilder.appendLine($"public partial class {classSymbol.Name}");
    codeBuilder.appendLine("{", CodeBuilder.IdentChange.IncreaseAfter);
    
    codeBuilder.appendLine($"public static {classSymbol.Name} Instance {{ get; private set; }}");
    codeBuilder.appendEmptyLine();
    codeBuilder.appendLine("void InitSingleton()");
    codeBuilder.appendLine("{", CodeBuilder.IdentChange.IncreaseAfter);
    codeBuilder.appendLine("if (Instance != null && Instance != this)");
    codeBuilder.appendLine("{", CodeBuilder.IdentChange.IncreaseAfter);
    codeBuilder.appendLine("Destroy(this);");
    codeBuilder.appendLine("}", CodeBuilder.IdentChange.DecreaseBefore);
    codeBuilder.appendLine("else");
    codeBuilder.appendLine("{", CodeBuilder.IdentChange.IncreaseAfter);
    codeBuilder.appendLine("Instance = this;");
    codeBuilder.appendLine("}", CodeBuilder.IdentChange.DecreaseBefore); 
    codeBuilder.appendLine("}", CodeBuilder.IdentChange.DecreaseBefore);
    
    for (var j = 0; j < indentCount; j++)
    {
      codeBuilder.appendLine("}", CodeBuilder.IdentChange.DecreaseBefore);
    }
    
    if (!classSymbol.ContainingNamespace.IsGlobalNamespace)
    {
      codeBuilder.appendLine("}", CodeBuilder.IdentChange.DecreaseBefore);
    }
    codeBuilder.appendLine("}", CodeBuilder.IdentChange.DecreaseBefore);
    
    return codeBuilder.getResult();
  }
}

internal class SyntaxReceiver : ISyntaxContextReceiver
{
  public List<INamedTypeSymbol> classes { get; } = new();

  public void OnVisitSyntaxNode(GeneratorSyntaxContext context)
  {
    if (context.Node is not ClassDeclarationSyntax { AttributeLists.Count: > 0 } classDeclarationSyntax) return;

    var classSymbol = Unsafe.As<INamedTypeSymbol>(
      context.SemanticModel.GetDeclaredSymbol(classDeclarationSyntax)
    );
    
    var haveAttribute =
      classSymbol?.GetAttributes().Any(ad =>
        ad.AttributeClass?.ToDisplayString() == SingletonGenerator.AttributeName
      ) ?? false;
    
    if (haveAttribute)
    {
      classes.Add(classSymbol);
    }
  }
}