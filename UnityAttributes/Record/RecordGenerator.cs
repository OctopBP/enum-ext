using System.Collections.Generic;
using System.Linq;
using System.Runtime.CompilerServices;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;
using UnityAttributes.Common;
using UnityAttributes.PublicAccessor;

namespace UnityAttributes.Record; 

// [Generator]
public partial class RecordGenerator : ISourceGenerator {
  static readonly string generatedCodeAttribute = typeof(RecordGenerator).generatedCodeAttribute();

  public void Initialize(GeneratorInitializationContext context) {
    // context.RegisterForPostInitialization(i => i.AddSource($"{AttributeName}.g.cs", attributeText));
    // context.RegisterForSyntaxNotifications(() => new SyntaxReceiver());
  }

  public void Execute(GeneratorExecutionContext context) {
    if (context.SyntaxContextReceiver is not SyntaxReceiver receiver)
      return;
    
    var groups = receiver.fields.GroupBy<IFieldSymbol, INamedTypeSymbol>(
      f => f.ContainingType, SymbolEqualityComparer.Default
    );

    foreach (var classSymbol in groups) {
      var classSource = processClass(classSymbol.Key);
      context.AddSource($"{classSymbol.Key.Name}.record.g.cs", SourceText.From(classSource, Encoding.UTF8));
    }
  }

  static string processClass(INamedTypeSymbol classSymbol) {
    var codeBuilder = new CodeBuilder();

    codeBuilder.append(Const.AutoGeneratedText);
    codeBuilder.appendEmptyLine();
    
    if (!classSymbol.ContainingNamespace.IsGlobalNamespace) {
      codeBuilder.appendLine(
        text: $"namespace {string.Join(".", classSymbol.ContainingNamespace.ConstituentNamespaces)} {{",
        identChange: CodeBuilder.IdentChange.IncreaseAfter
      );
    }

    var containingType = classSymbol.ContainingType;
    var i = 0;
    while (containingType != null) {
      codeBuilder.appendLine($"public partial class {containingType.Name} {{", CodeBuilder.IdentChange.IncreaseAfter);
      
      containingType = containingType.ContainingType;
      i++;
    }
    codeBuilder.appendLine($"public partial class {classSymbol.Name} {{", CodeBuilder.IdentChange.IncreaseAfter);
    
    // var fieldsParam = string.Join(", ", fieldsSymbols.Select(f => $"{f.Type} {f.Name}"));

    // codeBuilder.appendLine($"// fieldsSymbols.Length: {fieldsSymbols.Length}");
    
    // codeBuilder.appendLine($"public {classSymbol.Name}({fieldsParam}) {{", CodeBuilder.IdentChange.IncreaseAfter);
    // foreach (var fieldSymbol in fieldsSymbols) {
    //   processField(codeBuilder, fieldSymbol);
    // }
    // codeBuilder.appendLine("}", CodeBuilder.IdentChange.DecreaseBefore);
    
    for (var j = 0; j < i; j++) {
      codeBuilder.appendLine("}", CodeBuilder.IdentChange.DecreaseBefore);
    }
    
    if (!classSymbol.ContainingNamespace.IsGlobalNamespace) {
      codeBuilder.appendLine("}", CodeBuilder.IdentChange.DecreaseBefore);
    }
    codeBuilder.appendLine("}", CodeBuilder.IdentChange.DecreaseBefore);
    
    return codeBuilder.getResult();
    
    static void processField(CodeBuilder codeBuilder, IFieldSymbol fieldSymbol) {
      var fieldName = fieldSymbol.Name;
      codeBuilder.appendLine($"this.{fieldName} = {fieldName};");
    }
  }
}

internal class SyntaxReceiver : ISyntaxContextReceiver {
  public List<IFieldSymbol> fields { get; } = new();

  public void OnVisitSyntaxNode(GeneratorSyntaxContext context) {
    if (context.Node is not FieldDeclarationSyntax { AttributeLists.Count: > 0 } fieldDeclarationSyntax) return;
    
    foreach (var variable in fieldDeclarationSyntax.Declaration.Variables) {
      var fieldSymbol = context.SemanticModel.GetDeclaredSymbol(variable) as IFieldSymbol;
      var haveAttribute =
        fieldSymbol != null
        && fieldSymbol.GetAttributes()
          .Any(ad =>
            ad.AttributeClass != null
            && ad.AttributeClass.ToDisplayString() == PublicAccessorGenerator.AttributeName
          );

      if (haveAttribute) {
        fields.Add(fieldSymbol);
      }
    }
  }
}

internal class SyntaxReceiver2 : ISyntaxContextReceiver {
  // public List<(INamedTypeSymbol classSymbol, IFieldSymbol[] fieldsSymbols)> classes { get; } = new();
  public List<INamedTypeSymbol> classes { get; } = new();

  public void OnVisitSyntaxNode(GeneratorSyntaxContext context) {
    // if (context.Node is not ClassDeclarationSyntax { AttributeLists.Count: > 0 } classDeclarationSyntax) return;
    var classDeclarationSyntax = Unsafe.As<ClassDeclarationSyntax>(context.Node);

    if (classDeclarationSyntax == null) return;
    
    var classSymbol = Unsafe.As<INamedTypeSymbol>(
      context.SemanticModel.GetDeclaredSymbol(classDeclarationSyntax)
    );
    var haveAttribute =
      classSymbol != null
      && classSymbol.GetAttributes().Any(ad =>
        ad.AttributeClass != null
        && ad.AttributeClass.ToDisplayString() == RecordGenerator.AttributeName
      );
    if (haveAttribute) {
      classes.Add(classSymbol);
      // var fields = classDeclarationSyntax
      //   .ChildNodes()
      //   .OfType<FieldDeclarationSyntax>()
      //   // .Where(field => field.Modifiers.Any(SyntaxKind.PublicKeyword))
      //   // .Where(field => field.Modifiers.Any(SyntaxKind.ReadOnlyKeyword))
      //   .Select(field => Unsafe.As<IFieldSymbol>(context.SemanticModel.GetDeclaredSymbol(field)))
      //   .ToArray();
      //
      // classes.Add((classSymbol, fields));
    }
  }
}