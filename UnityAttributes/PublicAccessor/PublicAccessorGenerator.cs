using System;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace UnityAttributes.PublicAccessor; 

[Generator]
public partial class PublicAccessorGenerator : ISourceGenerator {
  static readonly AssemblyName assemblyName = typeof(PublicAccessorGenerator).Assembly.GetName();
  static readonly string generatedCodeAttribute =
    $@"[global::System.CodeDom.Compiler.GeneratedCodeAttribute(""{assemblyName.Name}"", ""{assemblyName.Version}"")]";
  
  public void Initialize(GeneratorInitializationContext context) {
    context.RegisterForPostInitialization(i => i.AddSource($"{AttributeName}.g.cs", attributeText));
    context.RegisterForSyntaxNotifications(() => new SyntaxReceiver());
  }

  public void Execute(GeneratorExecutionContext context) {
    if (context.SyntaxContextReceiver is not SyntaxReceiver receiver)
      return;
    
    var groups = receiver.fields.GroupBy<IFieldSymbol, INamedTypeSymbol>(
      f => f.ContainingType, SymbolEqualityComparer.Default
    );

    foreach (var group in groups) {
      var classSource = processClass(group.Key, group.ToArray());
      context.AddSource($"{group.Key.Name}.transformed.g.cs", SourceText.From(classSource, Encoding.UTF8));
    }
  }

  static string processClass(INamedTypeSymbol classSymbol, IFieldSymbol[] fields) {
    var source = new StringBuilder();
    
    source.Append(@"//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
");

    var ident = 0;
    
    source.AppendLine();
    if (!classSymbol.ContainingNamespace.IsGlobalNamespace) {
      source.AppendLine($"namespace {string.Join(".", classSymbol.ContainingNamespace.ConstituentNamespaces)} {{");
      ident++;
    }
    // source.AppendLine($"  {generatedCodeAttribute}");

    var containingType = classSymbol.ContainingType;
    var i = 0;
    while (containingType != null) {
      appendLineWith(source, $"public partial class {containingType.Name} {{", ident);
      
      containingType = containingType.ContainingType;
      i++;
      ident++;
    }
    appendLineWith(source, $"public partial class {classSymbol.Name} {{", ident);
    ident++;

    foreach (var fieldSymbol in fields) {
      processField(source, fieldSymbol, ident);
    }
    
    for (var j = 0; j < i; j++) {
      ident--;
      appendLineWith(source, "}", ident);
    }
    
    if (!classSymbol.ContainingNamespace.IsGlobalNamespace) {
      ident--;
      appendLineWith(source, "}", ident);
    }
    source.AppendLine("}");
    return source.ToString();
  }

  static void processField(StringBuilder source, IFieldSymbol fieldSymbol, int ident) {
    var fieldName = fieldSymbol.Name;
    var fieldType = fieldSymbol.Type;

    source.AppendLine();
    appendLineWith(source, $"/// Public accessor for <see cref=\"{fieldName}\"/>", ident);
    appendLineWith(source, $"/// <inheritdoc cref=\"{fieldName}\"/>", ident);
    appendLineWith(source, $"public {fieldType} _{fieldName} => {fieldName};", ident);
  }

  static void appendLineWith(StringBuilder source, string text, int ident = 0) {
    source.AppendLine(identToSpaces(ident) + text);
    
    string identToSpaces(int n) {
      var textAsSpan = "  ".AsSpan();
      var span = new Span<char>(new char[textAsSpan.Length * n]);
      for (var idx = 0; idx < n; idx++) {
        textAsSpan.CopyTo(span.Slice(idx * textAsSpan.Length, textAsSpan.Length));
      }

      return span.ToString();
    }
  }
}

internal class SyntaxReceiver : ISyntaxContextReceiver {
  public List<IFieldSymbol> fields { get; } = new();

  public void OnVisitSyntaxNode(GeneratorSyntaxContext context) {
    if (context.Node is not FieldDeclarationSyntax { AttributeLists.Count: > 0 } fieldDeclarationSyntax) return;
    
    foreach (var variable in fieldDeclarationSyntax.Declaration.Variables) {
      var fieldSymbol = context.SemanticModel.GetDeclaredSymbol(variable) as IFieldSymbol;
      var haveAttribute =
        fieldSymbol != null
        && fieldSymbol.GetAttributes()
          .Any(ad =>
            ad.AttributeClass != null
            && ad.AttributeClass.ToDisplayString() == PublicAccessorGenerator.AttributeName
          );

      if (haveAttribute) {
        fields.Add(fieldSymbol);
      }
    }
  }
}